<link rel="import" href="../wired-lib/wired-lib.html">

<dom-module id="wired-textarea">
  <template>
    <style>
       :host {
        display: inline-block;
        position: relative;
        padding: 5px;
        font-family: sans-serif;
        width: 400px;
        -moz-appearance: textarea;
        -webkit-appearance: textarea;
      }

       :host(.disabled) {
        opacity: 0.6 !important;
        cursor: default;
        pointer-events: none;
      }

       :host(.disabled) svg {
        background: rgba(0, 0, 0, 0.07);
      }

      .fit {
        position: absolute;
        top: 0;
        left: 0;
        right: 0;
        bottom: 0;
      }

      .overlay {
        pointer-events: none;
      }

      svg {
        display: block;
      }

      path {
        stroke: currentColor;
        stroke-width: 0.7;
        fill: transparent;
      }

      .mirror-text {
        visibility: hidden;
        word-wrap: break-word;
      }

      textarea {
        position: relative;
        outline: none;
        border: none;
        resize: none;
        background: inherit;
        color: inherit;
        width: 100%;
        height: 100%;
        font-size: inherit;
        font-family: inherit;
        line-height: inherit;
        text-align: inherit;
        padding: 5px;
      }
    </style>
    <div id="mirror" class="mirror-text">&#160;</div>
    <div class="fit">
      <textarea id="textarea" name$="[[name]]" autocomplete$="[[autocomplete]]" autofocus$="[[autofocus]]" inputmode$="[[inputmode]]"
        placeholder$="[[placeholder]]" readonly$="[[readonly]]" required$="[[required]]" disabled$="[[disabled]]" rows$="[[rows]]"
        minlength$="[[minlength]]" maxlength$="[[maxlength]]" on-input="_onInput"></textarea>
    </div>
    <div class="fit overlay">
      <svg id="svg"></svg>
    </div>
  </template>

  <script>
    class WiredTextarea extends Polymer.Element {
      static get is() { return 'wired-textarea'; }

      static get properties() {
        return {
          value: {
            observer: '_valueChanged',
            type: String,
            notify: true
          },
          rows: {
            type: Number,
            value: 1
          },
          maxRows: {
            type: Number,
            value: 0,
            observer: '_updateCached'
          },
          autocomplete: {
            type: String,
            value: 'off'
          },
          autofocus: {
            type: Boolean,
            value: false
          },
          inputmode: {
            type: String
          },
          placeholder: {
            type: String
          },
          readonly: {
            type: String
          },
          required: {
            type: Boolean
          },
          minlength: {
            type: Number
          },
          maxlength: {
            type: Number
          },
          disabled: {
            type: Boolean,
            value: false,
            observer: '_onDisableChange'
          }
        }
      }

      get textarea() {
        return this.$.textarea;
      }

      _valueChanged(value) {
        var textarea = this.textarea;
        if (!textarea) {
          return;
        }
        if (textarea.value !== value) {
          textarea.value = !(value || value === 0) ? '' : value;
        }
        this.$.mirror.innerHTML = this._valueForMirror();

        setTimeout(() => {
          this._needsLayout();
        }, 10);
      }

      _onInput(event) {
        this.value = this.$.textarea.value;
      }

      _constrain(tokens) {
        var _tokens;
        tokens = tokens || [''];
        if (this.maxRows > 0 && tokens.length > this.maxRows) {
          _tokens = tokens.slice(0, this.maxRows);
        } else {
          _tokens = tokens.slice(0);
        }
        while (this.rows > 0 && _tokens.length < this.rows) {
          _tokens.push('');
        }
        return _tokens.join('<br/>') + '&#160;';
      }

      _valueForMirror() {
        var input = this.textarea;
        if (!input) {
          return;
        }
        this.tokens = (input && input.value) ? input.value.replace(/&/gm, '&amp;').replace(/"/gm, '&quot;').replace(/'/gm, '&#39;').replace(/</gm, '&lt;').replace(/>/gm, '&gt;').split('\n') : [''];
        return this._constrain(this.tokens);
      }

      _updateCached() {
        this.$.mirror.innerHTML = this._constrain(this.tokens);
      }

      connectedCallback() {
        super.connectedCallback();
        this.style.opacity = 0;
        Polymer.RenderStatus.beforeNextRender(this, () => {
          setTimeout(() => {
            this._relayout();
            this.style.opacity = 1;
          }, 150);
        });
      }

      _clearNode(node) {
        while (node.hasChildNodes()) {
          node.removeChild(node.lastChild);
        }
      }

      _needsLayout() {
        var s = this.getBoundingClientRect();
        if (s.height != this._prevHeight) {
          this._relayout();
        }
      }

      _relayout() {
        this._clearNode(this.$.svg);
        var s = this.getBoundingClientRect();
        this.$.svg.setAttribute("width", s.width);
        this.$.svg.setAttribute("height", s.height);
        this._prevHeight = s.height;
        _WIRES_.rectangle(this.$.svg, 0, 0, s.width, s.height);
      }

      _onDisableChange() {
        if (this.disabled) {
          this.classList.add("disabled");
        } else {
          this.classList.remove("disabled");
        }
      }
    }

    window.customElements.define(WiredTextarea.is, WiredTextarea);
  </script>
</dom-module>